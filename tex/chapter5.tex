\chapter{仿真与实验}

\section{仿真平台与算法评价指标}
为验证本文算法的有效性，在MATLAB R2014a 环境下进行仿真。在仿真中对机器人动力学模型进行简化。首先不考虑障碍物对机器人的影响，即式\ref{eq:outside_control}中$f_r(p_i,v_i) = 0$。其次，另位置和速度的增益系数为$1$,则式\ref{eq:object_control}中的系数$a_a=1, a_m=1$。同时考虑在静态编队情况下进行自修复的仿真，所以机器人的期望速度为0，即式\ref{eq:object_control}中的$v(t) = 0$。本仿真是在二维空间下进行，采用112个机器人构成的6邻居编队网络模型，如图\ref{fig:simulation_topo}所示。图中每个空心圆代表一个机器人，机器人与机器人之间的连线表示他们之间的通信链接。机器人期望位置之间的距离为10，机器人的有效通信距离为12.5。
\begin{figure}[!htbp]
	\centering
	\includegraphics[width=10cm,height=7cm]{chapter5/figure5-1.png}
	\bicaption[fig:simulation_topo]{MATLAB平台下112个机器人构成的6邻居网络拓扑}{MATLAB平台下112个机器人构成的6邻居网络拓扑}{Fig}{The six-neighbor network topology constructed by 112 robots in MATLAB.}
\end{figure}

在仿真中，主要将本文所提算法与文献\parencite{张飞2008移动机器人覆盖问题的研究}中的无梯度分布情况下的自修复算法(下文称随机自修复算法)和文献\parencite{liu2015gradient}中的存在局部极小问题的自修复算法(下文称局部最优自修复算法)在相同的编队拓扑网络下进行比较。对算法的性能主要考察以下指标：\\
\indent 1)邻接矩阵的第二大特征值$\lambda_2$：由引理\ref{lem:lambda2}可知，邻接矩阵的第二大特征值$\lambda_2$可以用来衡量编队网络同步的稳定性和鲁棒性。$\lambda_2$越小，编队同步性能越好。此指标也是仿真中主要考察的一个指标。\\
\indent 2)修复机器人个数：修复机器人个数的多少代表着修复路径的长短，从而直接影响着编队自修复的效率，修复机器人个数越少，修复效率越高。\\
\indent 3)修复机器人总移动距离：此指标计算所有修复机器人在修复过程中移动距离的总和。之所以考察修复机器人的移动距离，是因为移动距离与能量消耗有关，在实际中具有重要意义。

\section{单个机器人丢失仿真对比}
首先进行单个机器人丢失的仿真对比。在相同的拓扑网络中使得同一个机器人丢失，分别应用不同的自修复算法进行自修复。图\ref{fig:random_single}描述了在由112个机器人构成的6邻居网络下进行的随机自修复仿真。坐标系内的所有实现圆点表示机器人的期望队形，每一个实心圆点对应一个机器人的期望位置。机器人中心的"x"表示机器人的当前位置。初始状态下，每一个机器人处在以期望位置为圆心，半径为5的范围内的一个随机位置，然后向期望位置移动，如图\ref{fig:random_single}(a)所示。当图\ref{fig:random_single}(b)中的空缺处出现机器人缺失时，根据文献\parencite{张飞2008移动机器人覆盖问题的研究}中的自修复规则选择一条修复路径，如图中红色机器人所示。修复机器人采用递归修复的方式一次填补对应的空缺，最终等效成一个度极小机器人修复缺失机器人。
\begin{figure*}[!htbp]
	\centering
	\begin{tabular}{cc}
	\subfigure[]{\includegraphics[width=6cm,height=6cm]{chapter5/Random_Single_a.png}} & 
	\hspace{1cm}
	\subfigure[]{\includegraphics[width=6cm,height=6cm]{chapter5/Random_Single_b.png}} \\
	\subfigure[]{\includegraphics[width=6cm,height=6cm]{chapter5/Random_Single_c.png}} &
	\hspace{1cm}
	\subfigure[]{\includegraphics[width=6cm,height=6cm]{chapter5/Random_Single_d.png}}	
	\end{tabular}
	\bicaption[fig:random_single]{6邻居网络拓扑下随机自修复算法仿真过程}{6邻居网络拓扑下随机自修复算法仿真过程}{Fig}{The process of random self-healing algorithm simulation for six neighbor network.}
\end{figure*}

由于随机自修复算法中只根据机器人度的信息进行判断，当多个满足条件的机器人度相同的时候，随机选择修复机器人。因此修复路径的随机性很大，可以看出图\ref{fig:random_single}中的修复路径并不是最短的，且存在局部极小问题。图\ref{fig:random_RepairingPath}中分别为仿真中其他几种修复路径。
\begin{figure*}[!htbp]
	\centering
	\begin{tabular}{cc}
		\subfigure[]{\includegraphics[width=6cm,height=6cm]{chapter5/figure5-3a.png}}　&
		\hspace{1cm}
		\subfigure[]{\includegraphics[width=6cm,height=6cm]{chapter5/figure5-3b.png}} \\
		\subfigure[]{\includegraphics[width=6cm,height=6cm]{chapter5/figure5-3c.png}} &
		\hspace{1cm}
		\subfigure[]{\includegraphics[width=6cm,height=6cm]{chapter5/figure5-3d.png}}
	\end{tabular}
	\bicaption[fig:random_RepairingPath]{随机自修复仿真中几种不同的修复路径}{随机自修复仿真中几种不同的修复路径}{Fig}{Several repairing paths for random self-healing algorithm.}
\end{figure*}

在文献\parencite{liu2015gradient}中引入了梯度信息，仿真过程如图\ref{fig:local_single}所示。代表机器人的圆圈中填充的颜色深浅表示梯度值的大小，颜色越深，梯度值越小，黑色表示梯度源节点。同样，空缺表示缺失机器人，图\ref{}(b)中缺失机器人与随机自修复仿真中的缺失机器人相同。红色圆圈代表修复机器人。由于引入梯度，因此算法降低了随机性，每次都能找到一条最短的修复路径。但是从仿真中也可以看出，算法存在的局部极小问题，仿真中最后的修复机器人度为3，而全局度最小的机器人度为2。因此同步性改善并不是最优的。
\begin{figure*}[!htbp]
	\centering
	\begin{tabular}{cc}
		\subfigure[]{\includegraphics[width=6cm,height=6cm]{chapter5/figure5-4a.png}}　&
		\hspace{1cm}
		\subfigure[]{\includegraphics[width=6cm,height=6cm]{chapter5/figure5-4b.png}} \\
		\subfigure[]{\includegraphics[width=6cm,height=6cm]{chapter5/figure5-4c.png}} &
		\hspace{1cm}
		\subfigure[]{\includegraphics[width=6cm,height=6cm]{chapter5/figure5-4d.png}}
	\end{tabular}
	\bicaption[fig:local_single]{6邻居网络拓扑下局部最优自修复算法仿真过程}{6邻居网络拓扑下局部最优自修复算法仿真过程}{Fig}{The process of local optimal self-healing algorithm simulation for six neighbor network.}
\end{figure*}

本文算法就是为避免以上问题，从而实现同步性改善全局最优而设计。通过改善梯度扩散的方式而避免局部极小问题。图\ref{fig:global_single}是本文的同步性改善全局最优的自修复算法仿真过程。从图\ref{fig:global_single}(a)中可以看出，本文算法最终形成的稳定梯度分布形式与文献\parencite{liu2015gradient}中的不同，在图\ref{fig:local_single}(a)中的那些度为3的梯度源节点被更新，不再是梯度源节点。当出现缺失机器人时，缺失机器人的邻居检测到缺失后，自身状态转移到候选修复状态进行竞选。竞选成功的机器人转移到修复状态，然后继续选择下一步修复机器人将修复状态传递下去，直到梯度源节点从而选出一条修复路径如图\ref{fig:global_single}(c)所示。修复完成后的网络拓扑如图\ref{fig:global_single}(d)所示。

\begin{figure*}[!htbp]
	\centering
	\begin{tabular}{cc}
		\subfigure[]{\includegraphics[width=6cm,height=6cm]{chapter5/figure5-5a.png}}　&
		\hspace{1cm}
		\subfigure[]{\includegraphics[width=6cm,height=6cm]{chapter5/figure5-5b.png}} \\
		\subfigure[]{\includegraphics[width=6cm,height=6cm]{chapter5/figure5-5c.png}} &
		\hspace{1cm}
		\subfigure[]{\includegraphics[width=6cm,height=6cm]{chapter5/figure5-5d.png}}
	\end{tabular}
	\bicaption[fig:global_single]{6邻居网络拓扑下全局最优自修复算法仿真过程}{6邻居网络拓扑下全局最优自修复算法仿真过程}{Fig}{The process of global optimal self-healing algorithm simulation for six neighbor network.}
\end{figure*}

在仿真中针对第二大特征值，修复机器人个数，修复机器人总移动距离三个指标将三种自修复算法进行了对比。图\ref{fig:simulation_result}是仿真结果的对比分析。在仿真中对同一个丢失机器人进行了十次重复试验，横坐标的实验ID表示$1~10$次实验。从图\ref{fig:simulation_result}(a)中可以看出，10次实验本文算法均取得了最小的第二大特征值，即意味着本文算法均获得了最优的同步性改善效果，且是稳定的。局部最优自修复算法虽然也是稳定的，但是由于产生了局部极小，因此无法取得最优的同步性改善效果。随机自修复算法由于存在过多的随机性，因此每一次的结果都无法保证相同，是不稳定的。对于修复机器人个数与修复机器人移动距离同样本文算法与局部最优自修复算法是稳定的，随机自修复算法不稳定。在修复机器人个数与修复机器人总移动距离的对比上，局部最优自修复算法当在产生局部极小问题时可能会获得比本文算法获得更少的修复机器人个数与总移动距离。但是根据前文3.4.3节有关修复时间的分析，虽然本文算法相比局部最优自修复算法具有更多的修复机器人个数与总移动距离，但是这并不会增加修复时间，因此对自修复的时间效率影响不大。
\begin{figure*}[!htbp]
	\centering
	\begin{tabular}{cc}
		\subfigure[第二大特征值对比结果]{\includegraphics[width=8cm,height=6cm]{chapter5/figure5-6a.png}} 
		\subfigure[修复机器人个数对比结果]{\includegraphics[width=8cm,height=6cm]{chapter5/figure5-6b.png}} \\
		\subfigure[修复机器人总移动距离对比结果]{\includegraphics[width=8cm,height=6cm]{chapter5/figure5-6c.png}}
	\end{tabular}
	\bicaption[fig:simulation_result]{三种自修复算法仿真结果对比}{三种自修复算法仿真结果对比}{Fig}{The comparation of simulation result among three self-healing algorithm.}
\end{figure*}

\section{多个机器人丢失仿真对比}
虽然单个机器人丢失的情况验证了本文算法的有效性和可行性，但是实际情况中可能存在不止一个机器人丢失的情况。这些丢失机器人可能相互独立，可能互为邻居。然而我们假设丢失的机器人至少有一个邻居依然存在编队网络中。因为本文算法是完全分布式实现的，机器人只能和邻居通信，也只有机器人的邻居能够感知到它的存在于丢失。因此如果丢失的机器人所有邻居也全部丢失，则没有机器人能够感知到它的丢失，修复也就无法进行了。

图\ref{fig:random_multi}是在多机器人丢失的情况下应用随机自修复算法进行自修复所选择的修复路径。图中分别对应丢失2个，3个，4个，5个机器人时的修复路径。由于随机自修复算法随机性比较大，因此这是每种情况下的一次修复路径选择。
\begin{figure*}[!htbp]
	\centering
	\begin{tabular}{cc}
		\subfigure[丢失两个机器人]{\includegraphics[width=6cm,height=6cm]{chapter5/figure5-7a.png}} &
		\hspace{1cm}
		\subfigure[丢失三个机器人]{\includegraphics[width=6cm,height=6cm]{chapter5/figure5-7b.png}} \\
		\subfigure[丢失四个机器人]{\includegraphics[width=6cm,height=6cm]{chapter5/figure5-7c.png}} &
		\hspace{1cm}
		\subfigure[丢失五个机器人]{\includegraphics[width=6cm,height=6cm]{chapter5/figure5-7d.png}}	
	\end{tabular}
	\bicaption[fig:random_multi]{随机自修复算法针对多个丢失机器人的修复路径选择}{随机自修复算法针对多个丢失机器人的修复路径选择}{Fig}{The repairing paths of random self-healing algorithm for multiple failed robots.}
\end{figure*}

由于随机性的原因，某些修复路径包含的修复机器人会很多，这样就会导致多个机器人丢失后，整个编队过多机器人参与修复过程，这无论从编队的任务执行效率还是能量的消耗等方面都会造成不理的影响。而且在图\ref{fig:random_multi}(d)中由于3条修复路径使用两个度极小机器人，因此导致一条修复路径的最后一个修复机器人的空缺位置没有一个度极小机器人来填补，造成修复不完全的问题。这都是在随机自修复算法下会产生的问题。

图\ref{fig:local_multi}是在多机器人丢失的情况下应用局部最优自修复算法进行自修复所选择的修复路径。可以看到在引入梯度后多个丢失机器人的修复路径不会冲突，所以不会造成修复不完全的问题。同时还能够相对减少修复机器人的个数。

\begin{figure*}[!h]
	\centering
	\begin{tabular}{cc}
		\subfigure[丢失两个机器人]{\includegraphics[width=6cm,height=6cm]{chapter5/figure5-8a.png}} &
		\hspace{1cm}
		\subfigure[丢失三个机器人]{\includegraphics[width=6cm,height=6cm]{chapter5/figure5-8b.png}} \\
		\subfigure[丢失四个机器人]{\includegraphics[width=6cm,height=6cm]{chapter5/figure5-8c.png}} &
		\hspace{1cm}
		\subfigure[丢失五个机器人]{\includegraphics[width=6cm,height=6cm]{chapter5/figure5-8d.png}}
	\end{tabular}
	\bicaption[fig:local_multi]{局部最优自修复算法针对多个丢失机器人的修复路径选择}{局部最优自修复算法针对多个丢失机器人的修复路径选择}{Fig}{The repairing paths of local optimal self-healing algorithm for multiple failed robots.}
\end{figure*}
	
局部最优自修复算法的目的主要是在改善编队同步性过程中实现修复路径的最短，因此在牺牲了同步性改善效果之后针对每一个丢失机器人应该用最短的修复路径进行修复，然而在某些情况下该算法无法达到修复路径最短。当两个丢失机器人互为邻居时，可能会造成一个丢失机器人的最短修复路径包含另一个丢失机器人，如图\ref{fig:local_multi}(c)所示。此时就无法保证这个丢失机器人的修复路径最短。

图\ref{fig:global_multi}是在多机器人丢失的情况下应用全局最优自修复算法进行自修复所选择的修复路径。

\begin{figure*}[!htbp]
	\centering
	\begin{tabular}{cc}
		\subfigure[丢失两个机器人]{\includegraphics[width=6cm,height=6cm]{chapter5/figure5-9a.png}} &
		\hspace{1cm}
		\subfigure[丢失三个机器人]{\includegraphics[width=6cm,height=6cm]{chapter5/figure5-9b.png}} \\
		\subfigure[丢失四个机器人]{\includegraphics[width=6cm,height=6cm]{chapter5/figure5-9c.png}} &
		\hspace{1cm}
		\subfigure[丢失五个机器人]{\includegraphics[width=6cm,height=6cm]{chapter5/figure5-9d.png}}
	\end{tabular}
	\bicaption[fig:global_multi]{全局最优自修复算法针对多个丢失机器人的修复路径选择}{全局最优自修复算法针对多个丢失机器人的修复路径选择}{Fig}{The repairing paths of global optimal self-healing algorithm for multiple failed robots.}
\end{figure*}